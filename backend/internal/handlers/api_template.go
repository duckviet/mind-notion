/*
 * Modular JWT Authenticated API
 *
 * An example API using JWT imported from a separate file.
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package handlers

import (
	"net/http"
	"strings"

	dbmodels "github.com/duckviet/gin-collaborative-editor/backend/internal/database/models"
	"github.com/duckviet/gin-collaborative-editor/backend/internal/service"
	"github.com/gin-gonic/gin"
)

type TemplateAPI struct {
	templateService service.TemplateService
	authService     service.AuthService
}

// POST /api/v1/templates
// Create a new template
func (api *TemplateAPI) CreateTemplate(c *gin.Context) {
	// User injected by auth middleware
	userVal, ok := c.Get("user")
	if !ok {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
		return
	}
	u := userVal.(*dbmodels.User)

	// Bind body
	var body struct {
		Name    string   `json:"name"`
		Icon    string   `json:"icon"`
		Content string   `json:"content"`
		Tags    []string `json:"tags"`
		Color   string   `json:"color"`
	}
	if err := c.ShouldBindJSON(&body); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request, " + err.Error()})
		return
	}

	created, err := api.templateService.CreateTemplate(c.Request.Context(), service.CreateTemplateRequest{
		Name:    body.Name,
		Icon:    body.Icon,
		Content: body.Content,
		Tags:    body.Tags,
		Color:   body.Color,
		UserID:  u.ID,
	})
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	// Convert tags string to array for response
	var tags []string
	if created.Tags != "" {
		tags = strings.Split(created.Tags, ",")
	}

	response := gin.H{
		"id":         created.ID,
		"name":       created.Name,
		"icon":       created.Icon,
		"content":    created.Content,
		"tags":       tags,
		"color":      created.Color,
		"user_id":    created.UserID,
		"created_at": created.CreatedAt,
		"updated_at": created.UpdatedAt,
	}

	c.JSON(http.StatusCreated, response)
}

// GET /api/v1/templates/list
// List all templates for the authenticated user
func (api *TemplateAPI) ListTemplates(c *gin.Context) {
	// User injected by auth middleware
	userVal, ok := c.Get("user")
	if !ok {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
		return
	}
	u := userVal.(*dbmodels.User)

	templates, err := api.templateService.ListTemplatesByUserID(c.Request.Context(), u.ID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	// Convert templates to response format
	response := make([]gin.H, len(templates))
	for i, tmpl := range templates {
		var tags []string
		if tmpl.Tags != "" {
			tags = strings.Split(tmpl.Tags, ",")
		}

		response[i] = gin.H{
			"id":         tmpl.ID,
			"name":       tmpl.Name,
			"icon":       tmpl.Icon,
			"content":    tmpl.Content,
			"tags":       tags,
			"color":      tmpl.Color,
			"user_id":    tmpl.UserID,
			"created_at": tmpl.CreatedAt,
			"updated_at": tmpl.UpdatedAt,
		}
	}

	c.JSON(http.StatusOK, gin.H{"templates": response})
}

// GET /api/v1/templates/:id
// Get template by ID
func (api *TemplateAPI) GetTemplate(c *gin.Context) {
	idStr := c.Param("id")

	template, err := api.templateService.GetTemplateByID(c.Request.Context(), idStr)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
		return
	}

	// Ownership check
	userVal, _ := c.Get("user")
	u := userVal.(*dbmodels.User)
	if template.UserID != u.ID {
		c.JSON(http.StatusNotFound, gin.H{"error": "template not found"})
		return
	}

	// Convert tags string to array for response
	var tags []string
	if template.Tags != "" {
		tags = strings.Split(template.Tags, ",")
	}

	response := gin.H{
		"id":         template.ID,
		"name":       template.Name,
		"icon":       template.Icon,
		"content":    template.Content,
		"tags":       tags,
		"color":      template.Color,
		"user_id":    template.UserID,
		"created_at": template.CreatedAt,
		"updated_at": template.UpdatedAt,
	}

	c.JSON(http.StatusOK, response)
}

// PUT /api/v1/templates/:id/update
// Update template by ID
func (api *TemplateAPI) UpdateTemplate(c *gin.Context) {
	idStr := c.Param("id")

	// Ownership check
	template, err := api.templateService.GetTemplateByID(c.Request.Context(), idStr)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
		return
	}

	userVal, _ := c.Get("user")
	u := userVal.(*dbmodels.User)
	if template.UserID != u.ID {
		c.JSON(http.StatusNotFound, gin.H{"error": "template not found"})
		return
	}

	// Bind body
	var body struct {
		Name    string   `json:"name"`
		Icon    string   `json:"icon"`
		Content string   `json:"content"`
		Tags    []string `json:"tags"`
		Color   string   `json:"color"`
	}
	if err := c.ShouldBindJSON(&body); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request, " + err.Error()})
		return
	}

	updated, err := api.templateService.UpdateTemplate(c.Request.Context(), idStr, service.UpdateTemplateRequest{
		Name:    body.Name,
		Icon:    body.Icon,
		Content: body.Content,
		Tags:    body.Tags,
		Color:   body.Color,
	})
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	// Convert tags string to array for response
	var tags []string
	if updated.Tags != "" {
		tags = strings.Split(updated.Tags, ",")
	}

	response := gin.H{
		"id":         updated.ID,
		"name":       updated.Name,
		"icon":       updated.Icon,
		"content":    updated.Content,
		"tags":       tags,
		"color":      updated.Color,
		"user_id":    updated.UserID,
		"created_at": updated.CreatedAt,
		"updated_at": updated.UpdatedAt,
	}

	c.JSON(http.StatusOK, response)
}

// DELETE /api/v1/templates/:id/delete
// Delete template by ID
func (api *TemplateAPI) DeleteTemplate(c *gin.Context) {
	idStr := c.Param("id")

	// Ownership check
	template, err := api.templateService.GetTemplateByID(c.Request.Context(), idStr)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
		return
	}

	userVal, _ := c.Get("user")
	u := userVal.(*dbmodels.User)
	if template.UserID != u.ID {
		c.JSON(http.StatusNotFound, gin.H{"error": "template not found"})
		return
	}

	if err := api.templateService.DeleteTemplate(c.Request.Context(), idStr); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.Status(http.StatusNoContent)
}
