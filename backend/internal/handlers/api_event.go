/*
 * Modular JWT Authenticated API
 *
 * An example API using JWT imported from a separate file.
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package handlers

import (
	"errors"
	"net/http"
	"time"

	dbmodels "github.com/duckviet/gin-collaborative-editor/backend/internal/database/models"
	"github.com/duckviet/gin-collaborative-editor/backend/internal/dto"
	"github.com/duckviet/gin-collaborative-editor/backend/internal/repository"
	"github.com/duckviet/gin-collaborative-editor/backend/internal/service"
	"github.com/gin-gonic/gin"
)

type EventAPI struct {
	eventService *service.EventService
	authService  service.AuthService
}

// NewEventAPI creates a new event API handler
func NewEventAPI(eventService *service.EventService, authService service.AuthService) *EventAPI {
	return &EventAPI{
		eventService: eventService,
		authService:  authService,
	}
}

// Post /api/v1/events
// Create a new event 
func (api *EventAPI) CreateEvent(c *gin.Context) {
	// User injected by auth middleware
	userVal, ok := c.Get("user")
	if !ok {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
		return
	}
	u := userVal.(*dbmodels.User)

	var req dto.ReqCreateEvent
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	createReq := dtoToCreateRequest(&req, u.ID)
	event, err := api.eventService.CreateEvent(c.Request.Context(), createReq)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusCreated, eventToDTO(event))
}

// Delete /api/v1/events/:id/delete
// Delete an event 
func (api *EventAPI) DeleteEvent(c *gin.Context) {
	// User injected by auth middleware
	userVal, ok := c.Get("user")
	if !ok {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
		return
	}
	u := userVal.(*dbmodels.User)

	id := c.Param("id")
	if id == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid event ID"})
		return
	}

	err := api.eventService.DeleteEvent(c.Request.Context(), id, u.ID)
	if err != nil {
		if errors.Is(err, repository.ErrNotFound) {
			c.JSON(http.StatusNotFound, gin.H{"error": "event not found"})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "event deleted successfully"})
}

// Get /api/v1/events/:id
// Get a specific event by ID 
func (api *EventAPI) GetEventById(c *gin.Context) {
	// User injected by auth middleware
	userVal, ok := c.Get("user")
	if !ok {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
		return
	}
	u := userVal.(*dbmodels.User)

	id := c.Param("id")
	if id == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid event ID"})
		return
	}

	event, err := api.eventService.GetEvent(c.Request.Context(), id, u.ID)
	if err != nil {
		if errors.Is(err, repository.ErrNotFound) {
			c.JSON(http.StatusNotFound, gin.H{"error": "event not found"})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, eventToDTO(event))
}

// Get /api/v1/events/list
// List all events for the current user 
func (api *EventAPI) ListEvents(c *gin.Context) {
	// User injected by auth middleware
	userVal, ok := c.Get("user")
	if !ok {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
		return
	}
	u := userVal.(*dbmodels.User)

	eventType := c.Query("type")
	status := c.Query("status")

	events, err := api.eventService.ListEvents(c.Request.Context(), u.ID, eventType, status)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	response := dto.EventsListGet200Response{
		Data: eventsToDTO(events),
	}

	c.JSON(http.StatusOK, response)
}

// Get /api/v1/events/range
// List events within a date/time range 
func (api *EventAPI) ListEventsByRange(c *gin.Context) {
	// User injected by auth middleware
	userVal, ok := c.Get("user")
	if !ok {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
		return
	}
	u := userVal.(*dbmodels.User)

	startStr := c.Query("start_time")
	endStr := c.Query("end_time")
	eventType := c.Query("type")

	if startStr == "" || endStr == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "start_time and end_time parameters are required"})
		return
	}

	start, err := time.Parse(time.RFC3339, startStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid start time format, use RFC3339"})
		return
	}

	end, err := time.Parse(time.RFC3339, endStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid end time format, use RFC3339"})
		return
	}

	events, err := api.eventService.ListEventsInRange(c.Request.Context(), u.ID, start, end, eventType)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	response := dto.EventsListGet200Response{
		Data: eventsToDTO(events),
	}

	c.JSON(http.StatusOK, response)
}

// Patch /api/v1/events/:id/update
// Update an event 
func (api *EventAPI) UpdateEvent(c *gin.Context) {
	// User injected by auth middleware
	userVal, ok := c.Get("user")
	if !ok {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
		return
	}
	u := userVal.(*dbmodels.User)

	id := c.Param("id")
	if id == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid event ID"})
		return
	}

	var req dto.ReqUpdateEvent
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	updates := dtoToUpdateRequest(&req)
	event, err := api.eventService.UpdateEvent(c.Request.Context(), id, u.ID, updates)
	if err != nil {
		if errors.Is(err, repository.ErrNotFound) {
			c.JSON(http.StatusNotFound, gin.H{"error": "event not found"})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, eventToDTO(event))
}

