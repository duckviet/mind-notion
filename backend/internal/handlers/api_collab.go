/*
 * Modular JWT Authenticated API
 *
 * An example API using JWT imported from a separate file.
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package handlers

import (
	"net/http"
	"time"

	"github.com/duckviet/gin-collaborative-editor/backend/internal/config"
	dbmodels "github.com/duckviet/gin-collaborative-editor/backend/internal/database/models"
	"github.com/duckviet/gin-collaborative-editor/backend/internal/dto"
	"github.com/duckviet/gin-collaborative-editor/backend/internal/service"
	"github.com/golang-jwt/jwt/v5"
	"github.com/google/uuid"

	"github.com/gin-gonic/gin"
)

type CollabAPI struct {
	noteService service.NoteService
	authService service.AuthService
	config      *config.Config
}

type collabClaims struct {
	NoteID string `json:"note_id"`
	UserID string `json:"user_id"`
	Role   string `json:"role"`
	jwt.RegisteredClaims
}

func NewCollabAPI(noteService service.NoteService, authService service.AuthService, cfg *config.Config) *CollabAPI {
	return &CollabAPI{
		noteService: noteService,
		authService: authService,
		config:      cfg,
	}
}

// Post /api/v1/public/collab/token
// Create collaboration token for a note 
func (api *CollabAPI) CreateCollabToken(c *gin.Context) {
	var body dto.ReqCollabToken
	if err := c.ShouldBindJSON(&body); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request, " + err.Error()})
		return
	}
	if body.NoteId == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "note_id is required"})
		return
	}

	note, err := api.noteService.GetNoteByID(c.Request.Context(), body.NoteId)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "note not found"})
		return
	}

	role, userID := api.resolveEditorIdentity(c, note, body.EditToken)
	if role == "" {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
		return
	}

	token, err := api.signCollabToken(note.ID, userID, role)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to sign token"})
		return
	}

	c.JSON(http.StatusOK, dto.ResCollabToken{
		Token: token,
		Role:  role,
		Note:  toResCollabTokenNote(note),
	})
}

func (api *CollabAPI) resolveEditorIdentity(c *gin.Context, note *dbmodels.Note, editToken string) (string, string) {
	// Try owner auth (bearer or cookie)
	token := extractTokenFromRequest(c)
	if token != "" {
		user, err := api.authService.ValidateToken(c.Request.Context(), token)
		if err == nil && note.UserID == user.ID {
			return "owner", user.ID
		}
	}

	// Public edit token
	if editToken != "" && note.PublicEditEnabled && note.PublicEditToken == editToken {
		return "public_edit", "anon-" + uuid.NewString()
	}

	return "", ""
}

func (api *CollabAPI) signCollabToken(noteID, userID, role string) (string, error) {
	now := time.Now()
	claims := collabClaims{
		NoteID: noteID,
		UserID: userID,
		Role:   role,
		RegisteredClaims: jwt.RegisteredClaims{
			IssuedAt:  jwt.NewNumericDate(now),
			ExpiresAt: jwt.NewNumericDate(now.Add(time.Duration(api.config.Collab.TokenTTLMinutes) * time.Minute)),
		},
	}
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	return token.SignedString([]byte(api.config.Collab.TokenSecret))
}

func toResCollabTokenNote(note *dbmodels.Note) dto.ResCollabTokenNote {
	tags := make([]string, 0, len(note.Tags))
	for _, tag := range note.Tags {
		tags = append(tags, tag.Name)
	}

	return dto.ResCollabTokenNote{
		Id:                note.ID,
		Title:             note.Title,
		Content:           note.Content,
		ContentType:       note.ContentType,
		Status:            string(note.Status),
		TopOfMind:         note.TopOfMind,
		Thumbnail:         note.Thumbnail,
		Tags:              tags,
		FolderId:          note.FolderID,
		IsPublic:          note.IsPublic,
		PublicEditEnabled: note.PublicEditEnabled,
		PublicEditToken:   note.PublicEditToken,
		CreatedAt:         note.CreatedAt,
		UpdatedAt:         note.UpdatedAt,
	}
}
