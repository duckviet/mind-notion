/*
 * Modular JWT Authenticated API
 *
 * An example API using JWT imported from a separate file.
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package handlers

import (
	"fmt"
	"net/http"
	"strconv"

	dbmodels "github.com/duckviet/gin-collaborative-editor/backend/internal/database/models"
	"github.com/duckviet/gin-collaborative-editor/backend/internal/repository"
	"github.com/duckviet/gin-collaborative-editor/backend/internal/service"
	"github.com/gin-gonic/gin"
)

type NoteAPI struct {
    noteService service.NoteService
    authService service.AuthService
}

// Post /api/v1/notes
// Create a new note 
func (api *NoteAPI) CreateNote(c *gin.Context) {
    // User injected by auth middleware
	fmt.Println("CreateNote request:", c.Request.Context())
    userVal, ok := c.Get("user")
    if !ok {
        c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
        return
    }
    u := userVal.(*dbmodels.User)

    // Bind body
    var body struct {
        Title       string   `json:"title"`
        Content     string   `json:"content"`
        ContentType string   `json:"content_type"`
        Status      string   `json:"status"`
        Thumbnail   string   `json:"thumbnail"`
        Tags        []string `json:"tags"`
        FolderID    *string  `json:"folder_id"`
        IsPublic    bool     `json:"is_public"`
    }
    if err := c.ShouldBindJSON(&body); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request, " + err.Error()})
        return
    }

    created, err := api.noteService.CreateNote(c.Request.Context(), service.CreateNoteRequest{
        Title:       body.Title,
        Content:     body.Content,
        ContentType: body.ContentType,
        Status:      body.Status,
        Thumbnail:   body.Thumbnail,
        FolderID:    body.FolderID,
        IsPublic:    body.IsPublic,
        UserID:      u.ID,
    })
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }

    c.JSON(http.StatusCreated, created)
}

// Delete /api/v1/notes/:id/delete
// Delete note by ID 
func (api *NoteAPI) DeleteNote(c *gin.Context) {
    idStr := c.Param("note_id")
 

    if err := api.noteService.DeleteNote(c.Request.Context(), idStr); err != nil {
        c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
        return
    }
    c.Status(http.StatusNoContent)
}

// Get /api/v1/notes/:id
// Get note by ID 
func (api *NoteAPI) GetNote(c *gin.Context) {
    idStr := c.Param("note_id")
 
    note, err := api.noteService.GetNoteByID(c.Request.Context(), idStr)
    if err != nil {
        c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
        return
    }
    // ownership check
    userVal, _ := c.Get("user")
    u := userVal.(*dbmodels.User)
    if note.UserID != u.ID {
        c.JSON(http.StatusNotFound, gin.H{"error": "note not found"})
        return
    }
    c.JSON(http.StatusOK, note)
}

// Get /api/v1/notes/list
// List user's notes 
func (api *NoteAPI) ListNotes(c *gin.Context) {
    // Optional filters
    limitStr := c.Query("limit")
    offsetStr := c.Query("offset")
    query := c.Query("query")
    folderID := c.Query("folder_id")

    limit := 20
    if limitStr != "" {
        if v, err := strconv.Atoi(limitStr); err == nil && v > 0 {
            limit = v
        }
    }
    offset := 0
    if offsetStr != "" {
        if v, err := strconv.Atoi(offsetStr); err == nil && v >= 0 {
            offset = v
        }
    }
    
    page := 1
    if limit > 0 {
        page = (offset / limit) + 1
    }

    // list only current user's notes
    userVal, _ := c.Get("user")
    u := userVal.(*dbmodels.User)
    params := repository.NoteListParams{Page: page, Limit: limit, Query: &query}
    if folderID != "" {
        params.FolderID = &folderID
    }
    notes, total, err := api.noteService.GetNotesByUserID(c.Request.Context(), u.ID, params)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }
    c.JSON(http.StatusOK, gin.H{"notes": notes, "total": total, "limit": limit, "offset": offset, "query": query})
}

// Put /api/v1/notes/:id/update
// Update note by ID 
func (api *NoteAPI) UpdateNote(c *gin.Context) {
    idStr := c.Param("note_id")

    var body struct {
        Title       string   `json:"title"`
        Content     string   `json:"content"`
        ContentType string   `json:"content_type"`
        Status      string   `json:"status"`
        Thumbnail   string   `json:"thumbnail"`
        Tags        []string `json:"tags"`
        FolderID    *string  `json:"folder_id"`
        IsPublic    *bool    `json:"is_public"`
    }
    if err := c.ShouldBindJSON(&body); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request, " + err.Error()})
        return
    }

    // Ensure ownership before update
    existing, err := api.noteService.GetNoteByID(c.Request.Context(), idStr)
    if err != nil {
        c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
        return
    }
    userVal, _ := c.Get("user")
    u := userVal.(*dbmodels.User)
    if existing.UserID != u.ID {
        c.JSON(http.StatusNotFound, gin.H{"error": "note not found"})
        return
    }

    updated, err := api.noteService.UpdateNote(c.Request.Context(), idStr, service.UpdateNoteRequest{
        Title:       body.Title,
        Content:     body.Content,
        ContentType: body.ContentType,
        Status:      body.Status,
        Thumbnail:   body.Thumbnail,
        FolderID:    body.FolderID,
        TagIDs:      []uint{}, // TODO: Convert string tags to tag IDs
        IsPublic:    body.IsPublic,
    })
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }
    c.JSON(http.StatusOK, updated)
}

// Put /api/v1/notes/:id?tom={tom}
// Update note top of mind by ID
func (api *NoteAPI) UpdateNoteTOM(c *gin.Context) {
    idStr := c.Param("note_id")
    tomStr := c.Query("tom")
    tom := tomStr == "true"
    fmt.Println("UpdateNoteTOM request:", tomStr, tom)
    updated, err := api.noteService.UpdateNoteTOM(c.Request.Context(), idStr, tom)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }
    c.JSON(http.StatusOK, updated)
}

// Get /api/v1/notes/list-tom
// List user's top of mind notes
func (api *NoteAPI) ListNotesTOM(c *gin.Context) {
    // Get authenticated user
    userVal, exists := c.Get("user")
    if !exists {
        c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
        return
    }
    u := userVal.(*dbmodels.User)

    notes, err := api.noteService.ListNotesTOM(c.Request.Context(), u.ID)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }
    c.JSON(http.StatusOK, notes)
}

// Get /api/v1/public/notes/:note_id
// Get public note by ID (no auth required)
func (api *NoteAPI) GetPublicNote(c *gin.Context) {
    idStr := c.Param("note_id")

    note, err := api.noteService.GetNoteByID(c.Request.Context(), idStr)
    if err != nil {
        c.JSON(http.StatusNotFound, gin.H{"error": "note not found"})
        return
    }

    // Only return if note is public
    if !note.IsPublic {
        c.JSON(http.StatusNotFound, gin.H{"error": "note not found"})
        return
    }

    c.JSON(http.StatusOK, note)
}