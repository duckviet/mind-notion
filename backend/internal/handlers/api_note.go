/*
 * Modular JWT Authenticated API
 *
 * An example API using JWT imported from a separate file.
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package handlers

import (
	"fmt"
	"log"
	"net/http"
	"strconv"

	dbmodels "github.com/duckviet/gin-collaborative-editor/backend/internal/database/models"
	"github.com/duckviet/gin-collaborative-editor/backend/internal/repository"
	"github.com/duckviet/gin-collaborative-editor/backend/internal/service"
	"github.com/gin-gonic/gin"
)

type NoteAPI struct {
    noteService service.NoteService
    authService service.AuthService
}

// Post /api/v1/notes
// Create a new note 
func (api *NoteAPI) CreateNote(c *gin.Context) {
    // User injected by auth middleware
	fmt.Println("CreateNote request:", c.Request.Context())
    userVal, ok := c.Get("user")
    if !ok {
        c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
        return
    }
    u := userVal.(*dbmodels.User)

    // Bind body
    var body struct {
        Title       string   `json:"title"`
        Content     string   `json:"content"`
        ContentType string   `json:"content_type"`
        Status      string   `json:"status"`
        Thumbnail   string   `json:"thumbnail"`
        Tags        []string `json:"tags"`
        FolderID    *string  `json:"folder_id"`
        IsPublic    bool     `json:"is_public"`
    }
    if err := c.ShouldBindJSON(&body); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request, " + err.Error()})
        return
    }

    created, err := api.noteService.CreateNote(c.Request.Context(), service.CreateNoteRequest{
        Title:       body.Title,
        Content:     body.Content,
        ContentType: body.ContentType,
        Status:      body.Status,
        Thumbnail:   body.Thumbnail,
        FolderID:    body.FolderID,
        IsPublic:    body.IsPublic,
        UserID:      u.ID,
    })
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }

    c.JSON(http.StatusCreated, created)
}

// Delete /api/v1/notes/:id/delete
// Delete note by ID 
func (api *NoteAPI) DeleteNote(c *gin.Context) {
    idStr := c.Param("note_id")
 

    if err := api.noteService.DeleteNote(c.Request.Context(), idStr); err != nil {
        c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
        return
    }
    c.Status(http.StatusNoContent)
}

// Get /api/v1/notes/:id
// Get note by ID 
func (api *NoteAPI) GetNote(c *gin.Context) {
    idStr := c.Param("note_id")
 
    note, err := api.noteService.GetNoteByID(c.Request.Context(), idStr)
    if err != nil {
        c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
        return
    }
    // ownership check
    userVal, _ := c.Get("user")
    u := userVal.(*dbmodels.User)
    if note.UserID != u.ID {
        c.JSON(http.StatusNotFound, gin.H{"error": "note not found"})
        return
    }
    c.JSON(http.StatusOK, note)
}

// Get /api/v1/notes/list
// List user's notes 
func (api *NoteAPI) ListNotes(c *gin.Context) {
    // Optional filters
    limitStr := c.Query("limit")
    offsetStr := c.Query("offset")
    query := c.Query("query")
    folderID := c.Query("folder_id")

    limit := 20
    if limitStr != "" {
        if v, err := strconv.Atoi(limitStr); err == nil && v > 0 {
            limit = v
        }
    }
    offset := 0
    if offsetStr != "" {
        if v, err := strconv.Atoi(offsetStr); err == nil && v >= 0 {
            offset = v
        }
    }
    
    page := 1
    if limit > 0 {
        page = (offset / limit) + 1
    }

    // list only current user's notes
    userVal, _ := c.Get("user")
    u := userVal.(*dbmodels.User)
    params := repository.NoteListParams{Page: page, Limit: limit, Query: &query}
    if folderID != "" {
        params.FolderID = &folderID
    }
    notes, total, err := api.noteService.GetNotesByUserID(c.Request.Context(), u.ID, params)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }
    c.JSON(http.StatusOK, gin.H{"notes": notes, "total": total, "limit": limit, "offset": offset, "query": query})
}

// Put /api/v1/notes/:id/update
// Update note by ID 
func (api *NoteAPI) UpdateNote(c *gin.Context) {
    idStr := c.Param("note_id")

    // Parse as map to detect which fields are present
    var rawBody map[string]interface{}
    if err := c.ShouldBindJSON(&rawBody); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request, " + err.Error()})
        return
    }

    // Extract fields with proper type handling
    var body struct {
        Title       string
        Content     string
        ContentType string
        Status      string
        Thumbnail   string
        Tags        []string
        FolderID    *string
        IsPublic    *bool
    }
    
    if val, ok := rawBody["title"].(string); ok {
        body.Title = val
    }
    if val, ok := rawBody["content"].(string); ok {
        body.Content = val
    }
    if val, ok := rawBody["content_type"].(string); ok {
        body.ContentType = val
    }
    if val, ok := rawBody["status"].(string); ok {
        body.Status = val
    }
    if val, ok := rawBody["thumbnail"].(string); ok {
        body.Thumbnail = val
    }
    
    hasFolderID := false
    if val, exists := rawBody["folder_id"]; exists {
        hasFolderID = true
        if val == nil {
            body.FolderID = nil
        } else if strVal, ok := val.(string); ok {
            body.FolderID = &strVal
        }
    }
    
    if val, exists := rawBody["is_public"]; exists {
        if boolVal, ok := val.(bool); ok {
            body.IsPublic = &boolVal
        }
    }

    if hasFolderID {
        if body.FolderID != nil {
            log.Printf("DEBUG UpdateNote - NoteID: %s, FolderID value: %s", idStr, *body.FolderID)
        } else {
            log.Printf("DEBUG UpdateNote - NoteID: %s, FolderID is nil (move to root)", idStr)
        }
    } else {
        log.Printf("DEBUG UpdateNote - NoteID: %s, no folder_id field", idStr)
    }

    // Ensure ownership before update
    existing, err := api.noteService.GetNoteByID(c.Request.Context(), idStr)
    if err != nil {
        c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
        return
    }
    userVal, _ := c.Get("user")
    u := userVal.(*dbmodels.User)
    if existing.UserID != u.ID {
        c.JSON(http.StatusNotFound, gin.H{"error": "note not found"})
        return
    }

    updated, err := api.noteService.UpdateNote(c.Request.Context(), idStr, service.UpdateNoteRequest{
        Title:          body.Title,
        Content:        body.Content,
        ContentType:    body.ContentType,
        Status:         body.Status,
        Thumbnail:      body.Thumbnail,
        FolderID:       body.FolderID,
        UpdateFolderID: hasFolderID,
        TagIDs:         []uint{}, // TODO: Convert string tags to tag IDs
        IsPublic:       body.IsPublic,
    })
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }
    c.JSON(http.StatusOK, updated)
}

// Put /api/v1/notes/:id?tom={tom}
// Update note top of mind by ID
func (api *NoteAPI) UpdateNoteTOM(c *gin.Context) {
    idStr := c.Param("note_id")
    tomStr := c.Query("tom")
    tom := tomStr == "true"
    fmt.Println("UpdateNoteTOM request:", tomStr, tom)
    updated, err := api.noteService.UpdateNoteTOM(c.Request.Context(), idStr, tom)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }
    c.JSON(http.StatusOK, updated)
}

// Get /api/v1/notes/list-tom
// List user's top of mind notes
func (api *NoteAPI) ListNotesTOM(c *gin.Context) {
    // Get authenticated user
    userVal, exists := c.Get("user")
    if !exists {
        c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
        return
    }
    u := userVal.(*dbmodels.User)

    notes, err := api.noteService.ListNotesTOM(c.Request.Context(), u.ID)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }
    c.JSON(http.StatusOK, notes)
}

// Get /api/v1/public/notes/:note_id
// Get public note by ID (no auth required)
func (api *NoteAPI) GetPublicNote(c *gin.Context) {
    idStr := c.Param("note_id")

    note, err := api.noteService.GetNoteByID(c.Request.Context(), idStr)
    if err != nil {
        c.JSON(http.StatusNotFound, gin.H{"error": "note not found"})
        return
    }

    // Only return if note is public
    if !note.IsPublic {
        c.JSON(http.StatusNotFound, gin.H{"error": "note not found"})
        return
    }

	// Hide edit token in public response
	note.PublicEditToken = ""
	note.PublicEditEnabled = false

    c.JSON(http.StatusOK, note)
}

// Get /api/v1/notes/:id/public-edit
// Get public edit settings (owner only)
func (api *NoteAPI) GetPublicEditSettings(c *gin.Context) {
    idStr := c.Param("note_id")

    note, err := api.noteService.GetNoteByID(c.Request.Context(), idStr)
    if err != nil {
        c.JSON(http.StatusNotFound, gin.H{"error": "note not found"})
        return
    }

    userVal, _ := c.Get("user")
    u := userVal.(*dbmodels.User)
    if note.UserID != u.ID {
        c.JSON(http.StatusNotFound, gin.H{"error": "note not found"})
        return
    }

    // Ensure token exists for owner view
    if note.PublicEditToken == "" {
        note, err = api.noteService.RotatePublicEditToken(c.Request.Context(), idStr)
        if err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
            return
        }
    }

    c.JSON(http.StatusOK, gin.H{
        "enabled": note.PublicEditEnabled,
        "token":   note.PublicEditToken,
    })
}

// Post /api/v1/notes/:id/public-edit
// Update public edit enabled flag (owner only)
func (api *NoteAPI) UpdatePublicEditSettings(c *gin.Context) {
    idStr := c.Param("note_id")

    var body struct {
        Enabled bool `json:"enabled"`
    }
    if err := c.ShouldBindJSON(&body); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request, " + err.Error()})
        return
    }

    note, err := api.noteService.GetNoteByID(c.Request.Context(), idStr)
    if err != nil {
        c.JSON(http.StatusNotFound, gin.H{"error": "note not found"})
        return
    }

    userVal, _ := c.Get("user")
    u := userVal.(*dbmodels.User)
    if note.UserID != u.ID {
        c.JSON(http.StatusNotFound, gin.H{"error": "note not found"})
        return
    }

    updated, err := api.noteService.UpdatePublicEditSettings(c.Request.Context(), idStr, body.Enabled)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }

    c.JSON(http.StatusOK, gin.H{
        "enabled": updated.PublicEditEnabled,
        "token":   updated.PublicEditToken,
    })
}

// Post /api/v1/notes/:id/public-edit/rotate
// Rotate public edit token (owner only)
func (api *NoteAPI) RotatePublicEditToken(c *gin.Context) {
    idStr := c.Param("note_id")

    note, err := api.noteService.GetNoteByID(c.Request.Context(), idStr)
    if err != nil {
        c.JSON(http.StatusNotFound, gin.H{"error": "note not found"})
        return
    }

    userVal, _ := c.Get("user")
    u := userVal.(*dbmodels.User)
    if note.UserID != u.ID {
        c.JSON(http.StatusNotFound, gin.H{"error": "note not found"})
        return
    }

    updated, err := api.noteService.RotatePublicEditToken(c.Request.Context(), idStr)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }

    c.JSON(http.StatusOK, gin.H{
        "enabled": updated.PublicEditEnabled,
        "token":   updated.PublicEditToken,
    })
}

// Post /api/v1/public/notes/:id/snapshot
// Save HTML snapshot (owner or public-edit token)
func (api *NoteAPI) SaveNoteSnapshot(c *gin.Context) {
    idStr := c.Param("note_id")

    var body struct {
        Content string `json:"content"`
    }
    if err := c.ShouldBindJSON(&body); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request, " + err.Error()})
        return
    }

    note, err := api.noteService.GetNoteByID(c.Request.Context(), idStr)
    if err != nil {
        c.JSON(http.StatusNotFound, gin.H{"error": "note not found"})
        return
    }

    if !api.canEditNote(c, note) {
        fmt.Print("[SaveSnapshot] - Can not edit note!")
        c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
        return
    }

    updated, err := api.noteService.SaveNoteSnapshot(c.Request.Context(), idStr, body.Content)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }

    c.JSON(http.StatusOK, gin.H{
        "id":         updated.ID,
        "updated_at": updated.UpdatedAt,
    })
}

func (api *NoteAPI) canEditNote(c *gin.Context, note *dbmodels.Note) bool {
    // Owner via middleware
    if userVal, ok := c.Get("user"); ok {
        u := userVal.(*dbmodels.User)
        return note.UserID == u.ID
    }

    // Owner via bearer token (public route)
    token := extractTokenFromRequest(c)
    if token != "" {
        user, err := api.authService.ValidateToken(c.Request.Context(), token)
        if err == nil && note.UserID == user.ID {
            return true
        }
    }

    // Public edit token
    editToken := getEditToken(c)
    if editToken != "" && note.PublicEditEnabled && note.PublicEditToken == editToken {
        return true
    }

    return false
}

func getEditToken(c *gin.Context) string {
    if token := c.GetHeader("X-Edit-Token"); token != "" {
        return token
    }
    return c.Query("token")
}